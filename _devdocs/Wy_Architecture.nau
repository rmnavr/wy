
// Modules: Frontend + Other ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	__init__.py		// lib header
  	__init_hy__.hy	// lib header
  	_fptk_local.hy	// Collection of FP-utility functions

	wy2hy.hy		// CLI App (Frontend)

// ____________________________________________________________________________/ }}}1
// Modules: Backend ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	Terminology:
	// OMARKER = ":" "L" "C" "`:" ...					| [O]peners
	//     SMARKER = OMARKER acting as group-starter	| Group [S]tarter
	//     MMARKER = OMARKER acting as mid-opener		| [M]id-opener
	// DMARKER = "::" "LL" "CC" ":#:" "C#C"				| [D]ouble-marker
	// CMARKER = "\"									| [C]ontinuator
	// AMARKER = "$"									| [A]pplicator
	// RMARKER = "<$"									| [R]everse-applicator
	// JMARKER = ","									| [J]oiner

	===========================================================================

	DDD style types definition for whole backend:

		Classes.hy			

	Transpilation pipe:

		Preparator.hy	 | [³WyCode (=str)⁺] -> [³PreparedCode (=str)⁺] 		                    // " x\n  y" -> "☇¦■x☇¦■■y"
						 | → $TAB=4 to spaces convertion is done here
						 | → trailing spaces are removed here

		Parser.hy		 | [³PreparedCode (=str)⁺] -> [³Token(s)⁺] -> [³NTLine(s)⁺]                 // "☇¦■x☇¦■■y" -> .. -> 2 NTLines
						 | ## throws error when ORPHANB found
						 | → "☇¦■" gargabe inside strings and hyexprs is removed at PAtom creation stage
						 | → [³Token(s)⁺] for whole wy_code are split into [³NTLine(s)⁺] by TKind.NewLine tokens, and they themselves are removed
						 | + Token.pkind is about parser classification (NUMBER, QSTRING, HYEXPR, etc.)
						 | + Token.tkind is about functional classification (RACont, Indent, RAOpener, ...)
						 | + [³NTLine⁺] = lineNs (x3) + tokens list

		Expander.hy		 | [³NTLine(s)⁺] -> [³NTLine(s)⁺]                                           // 2 NTLines -> 2+ NTLines (when "$" "<$" "," are present)
						 | → 1) OMARKERs are classified to SMARKER or MMARKER 
						 | → 2) Then syntax correctness checks (for [\ $ <$ ,]) are performed
						 |      ## throws error when wrong syntax for [\ $ <$ ,] is used
						 | → 3) Then expansion happens in the following order: SMARKERs, RMARKERs, AMARKERs, JMARKERs
						 | + for SMARKERs lines ending with ":" are not expanded (there is no need), but they are steel called SMARKERs

		Deconstructor.hy | [³NTLine(s)⁺] -> [³NDLine(s)⁺]											
						 | + NDLine.skind is about function of line (GroupStarter, Continuator, ... — overall 5 kinds)
						 | + [³NDLine⁺] = skind + lineN (x3) + ident (as int) + t_smarker* + body_tokens + t_ocomment*

		······························

		Bracketer.hy	 | [³NDLine(s)⁺] -> [³BLine(s)⁺]  
						 | → heavy cross-line indent-recognition lifting is done here (like: base on indents, should new level be opened/closed/keeped?)
						 |   ## throws error when indent mismatches
						 | → closers/openers are stored as literal "`(", "]" and such
						 | + [³BLine⁺] = ndline + prev_closers + this_openers

		Writer.hy		 | [³BLine(s)⁺] -> [³HyCode⁺]  
						 | → OMARKERs are dealt with here (method: ":" → 2 atoms: "(" inplace and ")" to the end of the line)
						 | → DMARKERs are dealt with here (method: 1 atom "::" → 2 atoms: ")" and "(")

		## Submodules errors are catched at this stage:
		Assembler.hy	 | [³WyCode (=str)⁺] -> [³HyCode⁺]  
						 | + also includes some REPL-related functions

		······························


// ____________________________________________________________________________/ }}}1


